---
Title: PlayのNettyServer
Category:
- Scala
- Play
Date: 2014-10-12T08:05:50+09:00
URL: https://krrrr.hatenablog.com/entry/2014/10/12/080550
EditURL: https://blog.hatena.ne.jp/krrrr/krrrr.hatenablog.com/atom/entry/8454420450068307076
---

PlayのNettyに対するアダプターとなるNettyServer、こいつが何をするのかと、ここでリクエストを受け取って処理するとこを見る。
`play.api...`で行うリクエスト受け取ってレスポンス返すとこは、Qiitaの以下らへんの記事見れば良いと思うので省略。`ContentType`を決定するあたりにアドホック多相とか使っててScalaっぽくて好き。

- [Play Frameworkのソースコードリーディング Action周り - Qiita](http://qiita.com/mtoyoshi/items/0679618fdfa710ded645)
- [Play Frameworkのソースコードリーディング Action周り(BodyParserとAnyContent) - Qiita](http://qiita.com/mtoyoshi/items/a5fcfb01a9bb56b2a492)
- あわせて読みたい: [やさしいIteratee入門 - slideshare](http://www.slideshare.net/TakashiKawachi/iteratee)

簡単にまとめると、`Netty`から受け取って`play.api`まで渡すまでに↓の過程を踏む

- `play.core.server.NettyServer`が↓の持ってる
- `play.core.server.netty.PlayDefaultUpstreamHandler.messageReceived`で↓の呼び出す
- `play.core.server.Server.getHandlerFor`が↓の持ってる
  - `play.core.server.Server.sendHandler`で↓の呼び出す
- `play.api.GlobalSettings.onRequestReceived: (RequestHeader, Handler)`では↓の3つの処理が行われる
  - `onRouteRequest(request)`
  - `router.handleFor(request)`
  - `doFilter(rh => handler)(routedRequest)`

以下で触れるのは2.3.xブランチの[このcommit上](https://github.com/playframework/playframework/tree/a5a11b9dc799d730713c3cbadf35a3e06f2b585b)の話、ただコードを読むだけ
<!-- more -->
#### play.core.server.Server
NettyServerが持つtraitの1つ

- `bodyParserTimeout`: どこでも使われて無くてウケる
- `mode`: Dev, Test, Prodとか
- `applicationProvider`
- `stop()`: Logger落とす
- `getHandlerFor`: 大事
  - `applicationProvider.handleWebCommand`
    - ブラウザ上でevolutionの実行をクリックするとかそういう処理
    - 失敗時はその様子を`Global.onError`上に載せて出す
  - `sendHandler`: __リクエストの処理__
    - `application.global.onRequestReceived(request)`

#### play.core.server.NettyServer
##### object NettyServer
- `main`持ってて`PlaySetting`内では`mainClass`がこいつを指定してる(`run`は下の`mainDevOnly~`が使われ、こちらは使われない)
- `main`から呼ばれる`createServer`では以下の事が行われPlayアプリケーションが起動する
  - pidの取得(`java.lang.management.ManagementFactory.getRuntimeMXBean.getName.split('@').headOption`)
  - pidファイルの指定を基本はアプリケーションルートのRUNNNING_PIDとする
  - runtimeのshutdownHookにpidファイルの削除を追加
  - `StaticApplication`を用いた`NettyServer`インスタンスの生成
    - `StaticApplication`はインスタンス生成時に`Play.start(application)`を呼ぶ
    - このへんは[前の前の記事](http://krrrr.hatenablog.com/entry/2014/10/03/235805)参考
  - runtimeのshutdownHookに`server.stop()`を追加
- `mainDevOnlyHttpMode`と`mainDevOnlyHttpsMode`も持ってて、`run`時にリフレクション使ってここが呼び出されてる(参考: [前の記事のPlayRunのとこ](http://krrrr.hatenablog.com/entry/2014/10/09/190017))

##### class NettyServer
- 先に述べた`Server`と`ServerWithStop`のtraitがmixinされてる

PlayのApplicationの情報を提供する`ApplicationProvider`やportなどを引数にNettyとのアダプターとなるクラス。インスタンス生成時に大まかな設定が全て用意される。

- NettyのBootstrapを用意
  - `netty-boss`、`netty-worker`に用いられるスレッドプールを用意
  - Netty用のオプション(`http.netty.option.`で始まるもの)をNettyに渡す
  - Nettyで用いるpipelineを提供する`PlayPipelineFactory`を設定する
- Nettyはpipelineに様々な処理を積んでく実装を行うため、Playでは以下のpipelineを順に積む
  - SSL接続の場合は`SslHandler`
  - `HttpRequestDecoder`
  - `HttpResponseEncoder`
  - `HttpContentDecompressor`
  - `HttpPipeliningHandler`
  - `defaultUpStreamHandler`: ここで`play.api`内の処理等を行う
    - 下の`PlayDefaultUpstreamHandler.messageReceived`へ続く
- `stop()`時の挙動
  - `Play.stop()`
  - `Server.stop()`
  - リクエストを送るチャンネルを閉じる
  - 外部リソースを開放

#### PlayDefaultUpstreamHandler
Nettyで使われるHandlerの1つになり、リクエストが来た際のNettyからPlayへの入り口及び出口となる

以下のメソッドをoverrideしてる

- `exceptionCaught`: 例外発生時に呼ばれるもの
  - `Logger("play.nettyException")`で例外の内容に応じてログを書き出し、チャンネルを閉じたりする
- `channelConnected`: チャンネルへの接続を行った時に呼ばれるもの
  - ssl接続の場合、SSLハンドシェイクを行う
- `channelDisconnected`: チャンネルの接続がはずれた時に呼ばれるもの
  - ChannelHandlerContextの中身を空にする
- `channelOpen`: チャンネルを開いた時に呼ばれるもの
  - 保持するチャンネルグループにイベントを伝播させるように設定する
- `messageReceiveed`: リクエストなどが飛んできた時に呼ばれるもの(今回の本題)
  - 下の方で別に見る

後で困るので先に、`EssentialAction`はこういうやつ。
```scala
trait EssentialAction extends (RequestHeader => Iteratee[Array[Byte], Result]) with Handler
```
```scala
object EssentialAction {
  def apply(f: RequestHeader => Iteratee[Array[Byte], Result]): EssentialAction = new EssentialAction {
    def apply(rh: RequestHeader) = f(rh)
  }
}
```

##### .messageReceived
リクエストの処理等を行う箇所

`HttpRequest`以外のイベントが飛んできたらログに吐いて終わり。`HttpRequest`に対しては以下の処理が行われる

- 来たリクエストを基に、新しい`rh: RequestHeader`の生成(Netty用のRequestHeaderからPlay用のものへ)
- rhを基に、`play.core.server.Server.getHandlerFor`からhandlerの取得
- handler: Handlerが`EssentialAction`か`Websocket`により処理の振り分け
- `EssentialAction`の場合
  - "`rh: RequestHeader`を引数に`handler`に食わせ`Iteratee[Array[Byte], Result]`をunflattenして、`Interatee`から`Step`を取り、結果として`Iteratee[Array[Byte], Result]`を返す関数"を引数に、`EssentialAction`オブジェクトから`EssentialAction`クラスのインスタンスを取得(下に実際のコード置いた)。エラー吐く際は`app.handleError`の結果が`EssentialAction`に渡される
  - `handleAction`にこいつ(`action: EssencialAction`)と、`app: Application`を渡す: 以下`handleAction`の話
    - 結局`play.api....`で定義した内容はここで処理される
  - actionに事前にPlay用に変換したrequestHeaderを与え、リクエストの中身である`Array[Byte]`から結果`Result`を生成する`bodyParser: Iteratee[Array[Byte], Result]`を用意
  - Chunkでデータが来る場合には、bodyParserを使い回し、`RequestBodyHandler`により順に処理して`Result`を得る
  - データがまとめて送られて来る場合には、リクエストから中身を読み込み、`Enumerator[Array[Byte]]`した上で先ほどのbodyParserに食わせ`Result`を得る
  - `Expect: 100-continue`ヘッダーの処理もここに存在
  - `play.core.server.netty.NettyResultStream.sendResult`: resultの種類により以下のように処理を振り分けつつ、各々の処理が終わるとチャンネル接続が閉じてる場合にはDownstreamへその情報を送る(このあたりは[他のNettyの記事](http://d.hatena.ne.jp/fatrow/20110208/netty)などを参考に)
    - ヘッダの値にnullが含まれている場合: InternalServerErrorとして結果を返し、接続を閉じる
    - `Transfer-Encoding`ヘッダがあり、HTTP1.0の場合: HTTP1.1を使うように505を返す
    - コネクションが閉じられる場合: チャンネルのコネクションが閉じられるような状態にしつつ、レスポンスのデータを順にEOFまでdownstreamへ送る
    - `Transfer-Encoding`ヘッダがある or `Content-Length`ヘッダがある場合: チャンネルのコネクションが閉じられるような状態にしつつ、レスポンスのデータを順にEOFまでdownstreamへ送る(ここ`EndOfBodyInProtocol`ってなっててよくわからん)
    - それ以外: bufferingしながらnettyResponseに内容入れてDonwstreamへ送る(途中HTTP1.1の場合は`Transfer-Encoding: Chunked`を設定しつつchunkを順に操作する)
  - 送った後は`global.onRequestCompletion`を`AtomicBoolean`で縛って一度だけ実行

```scala
val a = EssentialAction { rh =>
  import play.api.libs.iteratee.Execution.Implicits.trampoline
  Iteratee.flatten(action(rh).unflatten.map(_.it).recover {
  case error =>
    Iteratee.flatten(
      app.handleError(requestHeader, error).map(result => Done(result, Input.Empty))
      ): Iteratee[Array[Byte], Result]
  })
}
handleAction(a, Some(app))
```
