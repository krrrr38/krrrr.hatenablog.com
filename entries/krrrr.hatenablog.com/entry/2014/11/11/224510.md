---
Title: sbtの起動時にプロジェクトの設定を読むとこ + shellコマンド
Category:
- sbt
Date: 2014-11-11T22:45:10+09:00
URL: https://krrrr.hatenablog.com/entry/2014/11/11/224510
EditURL: https://blog.hatena.ne.jp/krrrr/krrrr.hatenablog.com/atom/entry/8454420450073236565
---

- bootの話(reload + shell)
  - `compile`とか`run`が入った`JvmPlugin`を読み込む所とかある

`sbt.xMain`では`boot`コマンドが初めに実行されるっての[前の前に](http://krrrr.hatenablog.com/entry/2014/11/05/102831)見た。

ここでは、sbt shellが立ち上がる前にbootにより`reload`コマンドが実行されている。

1. `reload`の話
2. `shell`の話
<!-- more -->
### プロジェクトの設定の読み込み: `reload`
ここでは、load失敗時のコマンド`load-failed`、失敗時のコマンドの仕切りを表す`resumeFromFailure`コマンドが追加されている。そしてプロジェクトの設定を読み込む`loadp`コマンドが読み込まれる。

- `loadp`は引数無し、`plugins`、`return`の3通りで動作し、LoadAction.Valueのenumとしてそれぞれ`Current`、`Plugins`、`Return`となる(以下、`Current`のみの処理を見る)
  - `Current`: (Re)loads the project in the current directory.
  - `Plugins`: (Re)loads the plugins project (under project directory).
  - `Return`: (Re)loads the root project (and leaves the plugins project).
- `sbt.BuildinCommands.doLoadProject`: loadpの実装
  - loadActionでは、`ProjectReturn`という属性(Attribute)に対し、LoadAction.Valueに応じて現在のStateに対し、値が設定される
    - 引数無しの`Current`の場合、現在のStateの`ProjectReturn`属性の値が設定されていればそのまま、設定されてなければbaseDirectoryのプロジェクトのみが`ProjectReturn`属性の値として設定される
  - baseDirectoryとなるディレクトリが存在していなければ、ここでディレクトリが作成される
    - build.sbtに簡単な設定を書いてsbtを起動すると勝手にディレクトリが作られるのはここ
  - stateにcompileのためのキャッシュが定義されてない時は、設定する
    - `compiler-cache`というAttributeを用いる
    - 新たに作成する際は、`CompilerCache.fresh: GlobalsCache`を用いる
    - GlobalCacheはOutput, xLogger, Reporterなどの引数を用いてCacheCompilerを作るinterface
  - `sbt.Load.defaultLoad` <- __なるほど__ : なんかめっちゃ設定する
    - `defaultPreGlobal`: clasloader, クラスパス, compilerとか探したりして、`LoadBuildConfiguration`作る
    - `defaultWithGlobal`
      - グローバルなプラグイン探して`GlobalPlugin.load`(TODO 後で見る)
      - グローバルなsbtの設定探して`loadGlobalSettings` (TODO 後で見る)
    - `Load.apply` <- __なるほど〜__ : やってること下の方にコメントそのまま載せてる
      - `compile`とか`run`の入った`JvmPlugin`はここから以下のように参照されてる(長い)
        - `sbt.Load.apply` -> `Load.load` -> `Loag.buildinLoader` -> `Load.loadUnit` -> `Load.plugins` -> `Load.buildPlugins/noPlugins` -> `Load.loadPluginDefinition` -> `Load.loadPlugins` -> `PluginDiscovery.discoverAll(data, loader))` -> `defaultAutoPlugins`
  - `sbt.Load.initialSession`
  - `Project.setProject`: 得られたsessionやloadした結果から得られるstructureからプロジェクトをセットする
    - `onLoad`と`onUnload`のhookを取得し、onUnloadを設定
    - `onLoad`はここで実行
    - ここで最後に`updateCurrent`ってのが呼ばれてる:`Project.updateCurrent(s: State): State`
      - プロジェクトの設定(BuildStructure)を読み込む
      - プロジェクト自体を読み込んだら、`onLoadMessage`を表示する
      - プロジェクトのGlobalコンフィギュレーションのコマンドとか、現在のセッションで定義されたコマンドなどをまとめて`s.definedCommands`に入れる

`Load.apply`でしてること、コメントには以下のように書いてる
> // build, load, and evaluate all units.  
> //  1) Compile all plugin definitions  
> //  2) Evaluate plugin definitions to obtain and compile plugins and get the resulting classpath for the build definition  
> //  3) Instantiate Plugins on that classpath  
> //  4) Compile all build definitions using plugin classpath  
> //  5) Load build definitions.  
> //  6) Load all configurations using build definitions and plugins (their classpaths and loaded instances).  
> //  7) Combine settings from projects, plugins, and configurations  
> //  8) Evaluate settings

ちなみに、デフォルトで読み込まれるpluginは以下の通り
```scala
val defaultAutoPlugins = Seq(
  "sbt.plugins.IvyPlugin" -> sbt.plugins.IvyPlugin,
  "sbt.plugins.JvmPlugin" -> sbt.plugins.JvmPlugin,
  "sbt.plugins.CorePlugin" -> sbt.plugins.CorePlugin,
  "sbt.plugins.JUnitXmlReportPlugin" -> sbt.plugins.JUnitXmlReportPlugin
)
```

### sbt shell: `shell`
プロジェクトの設定が読み込まれた後に、`shell`コマンドにより、sbt shellが立ち上がる。`shell`の定義は、`sbt.BasicCommands.shell`。

当然だが`shell`もコマンドの1つなので、Stateを取って実行後にStateを返すブロックを持つ。

ここでは、1行`line: String`を読み取って、以下のように前のStateから新しいStateを作る。

```scala
val newState = s.copy(onFailure = Some(Shell), remainingCommands = line +: Shell +: s.remainingCommands).setInteractive(true)
```

`remainincCommands`の先頭に読み込んだ`line`を入れて、その後に再度`shell`コマンドを入れる。コマンドを打つ毎に異なる`shell`が呼び出されてる事が分かる。

### 他のコマンドの実装例: alias
他のコマンドの実装例も軽く見る。

`alias`は`alias c=compile`みたいにすると`c`で`compile`が呼ばれるもの。`~/.sbtrc`に色々書いたりしとくと便利なやつ。
Stateから、既存のaliasがあるかとか確認しつつ、最終的に`s.copy(definedCommands = newAlias(name, value) +: s.definedCommands)`により新しいStateを返す。

`c`って名前のコマンドを`definedCommands`に追加してくれる。`c`の中身(`Parsr[() => State]`)は`c`ってした時の`State`の`remainingCommands`の前に、`compile`を入れてくれるってもの。

--------------------
Commandは大体終わり

### 次
InputKey, TaskKey, SettingKeyとかそのへん見たいんだけど、そもそもReferenceちゃんと読んでないの思い出したから先に読もう...

当たり前な事になるほど、とか言ってる気しかしない

http://www.scala-sbt.org/release/docs/Combined+Pages.html
