---
Title: Elixirの静的型チェック
Category:
- Elixir
Date: 2016-01-04T10:42:31+09:00
URL: https://krrrr.hatenablog.com/entry/2016/01/04/104231
EditURL: https://blog.hatena.ne.jp/krrrr/krrrr.hatenablog.com/atom/entry/6653586347151465404
---

### Elixir再履修

JVMはすごいけど限界もあるって最近感じてて、process単位でのGCが行えるBEAM系言語としてElixir触ってる((高級言語しか触ってなくて相変わらずダメだ))。

前に一度触ったけど文法とか飛んでたしElixir再履修。

- [Elixir Documentation](http://elixir-ja.sena-net.works/)
- [Elixir School](https://elixirschool.com/jp/)

エディタ設定とか依存管理とか予め言語開発側が用意してくれているので助かる。ただ動的型付け言語なので、その辺りは後々困るのは確実。Erlangには静的型チェックの仕組みとして[dialyzer](http://www.erlang.org/doc/man/dialyzer.html)があり、Elixirでも利用可能なのでそのあたりを先に押さえる。
<!-- more -->
### 型宣言

`when is_number(arg)`みたいのを適宜書くのも良いが、そもそもこれはガードに利用するためのもの。Erlangの型付けで利用されていた`-type`、`-spec`、`-opaque`
がそのまま`@type`、`@spec`、`@opaque`として利用出来る。

型についてのドキュメントは以下のページに記述されているので是非読むべき。

- [Erlang -- Types and Function Specifications](http://www.erlang.org/doc/reference_manual/typespec.html)
- [Kernel.Typespec – Elixir v1.1.1](http://elixir-lang.org/docs/v1.1/elixir/Kernel.Typespec.html)

さて、実際の例を[https://github.com/edgurgel/httpoison:title]を例に見てみる。

`get`では、`binary`, `headers`, `Keyword.t`を引数に取り、`{:ok, Response.t | AsyncResponse.t}` もしくは　`{:error, Error.t}`を返すという宣言を行っている。

```ruby
@spec get(binary, headers, Keyword.t) :: {:ok, Response.t | AsyncResponse.t} | {:error, Error.t}
def get(url, headers \\ [], options \\ []),          do: request(:get, url, "", headers, options)
```

この引数の型にある`binary`は予め用意された型だが、`headers`は独自に定義した型である。`headers`は`@type`を用いて以下の箇所で`[{binary, binary}]`として定義されている。`defmacro __using__(_)`はモジュールをuseした際に自動的に展開されるブロック。

```ruby
  defmacro __using__(_) do
    quote do
      @type headers :: [{binary, binary}]
    ...
```

なお、予め用意された型については、[Kernel.Typespec – Elixir v1.1.1](http://elixir-lang.org/docs/v1.1/elixir/Kernel.Typespec.html)の`Built-in types`の項目に記述されている。`nonempty_list`や`non_neg_integer`あたりあるのが面白い。

また、構造体の詳細な型付けは以下のように行える。ここでの`t`は`HTTPoison.Response.t`のことであり、`String.t`のように様々な構造体やプロトコルの型を表すものとなる((http://stackoverflow.com/a/29978255))。

```ruby
defmodule HTTPoison.Response do
  defstruct status_code: nil, body: nil, headers: []
  @type t :: %__MODULE__{status_code: integer, body: binary, headers: list}
end
```

### 静的型チェック

Elixirなら`Mix`を利用しているはずなので、[https://github.com/jeremyjh/dialyxir:title]を用いて`Mix`経由で型チェックを行う。

READMEにある通り以下の事を行えば、宣言された型に従い型チェックを行う。簡単。

#### 導入
mix.exs
```ruby
defp deps do
  [{:dialyxir, "~> 0.3", only: [:dev]}]
end
```

準備
```sh
> mix deps.get && mix deps.compile
> mix dialyzer.plt # 初回及びErlangやElixierのversionが変わった時のみ行う
```

#### 実行
```sh
> mix dialyzer
```

### 余談
`Stream.t`とか使えなくて微妙だ...

`__using__`について、Phoenixでは以下のようにあって、`use HelloPhoenix.Web, :controller` みたいに色々マクロを1つのmodule内に定義してた、面白い。

```ruby
  defmacro __using__(which) when is_atom(which) do
    apply(__MODULE__, which, [])
  end
```


### ref
- [http://qiita.com/niku/items/826f3c39c2b8bd99eb5a:title]
