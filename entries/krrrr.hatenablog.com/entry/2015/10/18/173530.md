---
Title: Tomcatの起動からの云々を追う
Category:
- Java
- tomcat
Date: 2015-10-18T17:35:30+09:00
URL: https://krrrr.hatenablog.com/entry/2015/10/18/173530
EditURL: https://blog.hatena.ne.jp/krrrr/krrrr.hatenablog.com/atom/entry/6653458415125006142
---

ソース読む。

PDFでフローだけ追いたい人は以下の2つ

- [起動フロー](http://tomcat.apache.org/tomcat-8.0-doc/architecture/startup/serverStartup.pdf)
- [リクエスト処理](http://tomcat.apache.org/tomcat-8.0-doc/architecture/requestProcess/request-process.png)

[このタイミングのコード](https://github.com/apache/tomcat/tree/7ab97204c397402b18b59621228c114c5d6bb7f0)読んでる。

[https://github.com/apache/tomcat:embed:cite]

<!-- more -->

- Bootstrap: `public static void main`
  - catalina.homeとcatalina.baseの設定
  - `daemon`に`new Bootstrap`して`init`したもの入れる
    - init
      - `initClassLoaders`
        - `commonLoader`, `catalinaLoader`, `sharedLoader`の3つのClassLoaderを作成
      - `Thread.currentThread().setContextClassLoader(catalinaLoader)`
      - `SecurityClassLoad.securityClassLoad(catalinaLoader);`
      - `catalinaLoader`から`org.apache.catalina.startup.Catalina`をロードして`startupClass`に入れて`startupInstance`を作成
      - `startupInstance`の`parentClassLoader`に`sharedLoader`をセット
      - `catalinaDaemon`を`startupInstance`とする
        - `catalinaDaemon`(`Catalina`)が実際のサーバ
    - 引数処理 (以下の`daemon`のメソッドでは、常に`catalinaDaemon`の同名のメソッドを呼ぶ)
      - `startd`
        - `daemon.load`, `daemon.start`
      - `start`
        - `daemon.setAwait(true)`, `daemon.load`, `daemon.start`
      - `stopd`
        - `daemon.stop`
      - `stop`
        - `daemon.stopServer`
      - `configtest`
        - `daemon.load`

- Catalina
  - `load`
    - `initDirs`: `java.io.tmpdir`の存在確認
    - `initNaming`
      - `"org.apache.naming"`を`"java.naming.factory.url.pkgs"`へ入れる
      - `"java.naming.factory.initial"`へ`"org.apache.naming.java.javaURLContextFactory"`を入れる
    - `digester`の作成
      - `server.xml`に記述されたxmlとJavaクラスのマッピングを行っている
      - 各々でデフォルト実装などが指定されてたりもする（デフォルト実装が無い場合には`className`などで指定する必要有り）
        - `Server`: `StandardServer`がデフォルト実装で、`setServer`へセットする
        - `Server/GlobalNamingResources`: `NamingResourcesImpl`がデフォルト実装で、`setGlobalNamingResources`へセットする
        - `Server/Listener`: デフォルト実装無しで、`Server/Listener`に`LifecycleListener`を取得し、`addLifecycleListener`へセットする
        - `Server/Service`: `StandardService`
        - `Server/Service/Listener`: デフォルト実装無し
        - `Server/Service/Executor`: `StandardThreadExecutor`
        - ...
    - 設定ファイル(`server.xml`, etc)を探して読み込み
    - `digester`に設定ファイルをparseさせる
    - `server`にcatalinaHomeとcatalinaBaseをセット
    - 標準出力と、標準エラー出力をスレッドベースなキャプチャが出来るような`SystemLogHandler`でラップ
    - `server.init()`(実態はLifecycle.init)
  - `start`
    - `server.start()`(実態はLifecyce.start)
  - `stop`
    - `server.stop()`, `server.destroy()` (実態はry)

- LifecycleBase: Lifecycleの状態の整合性を保持・比較しつつ、各internalなメソッドを呼び出す
  - リスナーを登録しておいて、各イベント発火時に各々に通知したり
  - `init`
    - `initInternal`
  - `start`
    - `startInternal`

- NamingResourcesImpl
  - `initInternal`
    - `ContextResource`, `ContextEnvironment`, `ContextResourceLink`のMBeanを作成
  - ...

- StandardServer
  - `Server`のデフォルト実装
  - `initInternal`
    - Stringのキャッシュ機構を提供
    - MBeanFactoryを作成
    - `globalNamingResources.init()`
    - 保持する全てのServiceに対し、`service.init()`
  - `startInternal`
    - `CONFIGURE_START_EVENT`というイベントをLifeCycleに投げる
    - LifecycleState.STARTING
    - `globalNamingResources.start()`
    - 保持する全てのServiceに対し、`service.start()`

- StandardService
  - `initInternal`
    - Container(= Engine, Context, Host)がある場合、その`init`
    - 保持するExecutor全ての`init`
    - `mapperListener.init()`
    - 保持するConnector全ての`init`
  - `startInternal`
    - LifecycleState.STARTING
    - Container(= Engine, Context, Host)がある場合、`container.start()`
    - 保持するExecutor全ての`start`
    - `mapperListener.start()`
    - 保持するConnector全ての`start`

- StandardThreadExecutor
  - Executorは与えられたコマンドを新しいスレッドで実行するためのもの
  - スレッドは基本的にプールされており、利用可能なスレッドが無い時は順次キューに入れられる
  - キューが一杯になると、`RejectedExecutionException`が投げられるまで待つ
  - `tomcat-exec-*`(namePrefix)というスレッドはこいつが保持するスレッド
  - `maxThreads`, `minSpareThreads`, `maxIdleTime`のデフォルト値などここにあり、全てThreadPoolExecutorのコンストラクタに渡されてる
  - `startInternal`
    - `TaskQueue(maxQueueSize)`の作成
    - `ThreadPoolExecutor`の作成
    - `setState(LifecycleState.STARTING)`
  - `execute`
    - 保持するThreadPoolExecutorのexecuteに投げる

- Connector: Coyote connectorの実装
  - パラメータ(default)
    - asyncTimeout(30000ms)
    - port(-1)
    - redirectPort(443)
    - scheme("http")
    - secure(false)
    - maxParameterCount(10000)
    - maxPostSize(2\*1024\*1024 = 2MB)
    - parseBodyMethods("POST"): カンマ区切りで指定出来る
    - protocolHandlerClassName("org.apache.coyote.http11.Http11NioProtocol")
    - adapter
    - ...
  - コンストラクタ
    - protocolHandlerに、（protocol="HTTP/1.1"の時は）`Http11AprProtocol`のインスタンスを入れる
  - `initInternal`
    - adapterに`CoyoteAdapter`をセット
    - `protocolHandler.init()`
  - `startInternal`
    - `protocolHandler.start()`
  - `createRequest`, `createResponse`
    - Adapterから呼ばれて、HttpServletRequest/Responseを継承した、自身に接続されたRequestとResponseを返す
  - `resume`: `protocolHandler.resume()`
  - `pause`: `protocolHandler.pause()`

- Http11AprProtocol: extends ... AbstractProtocol: プロトコルの実装の1つ
  - コンストラクタ
    - endpoint = `new AprEndpoint()`
    - `Http11ConnectionHandler`がendpointに対するHandlerとなる
  - `init`
    - `endpoint.init()`
  - `start`
    - `endpoint.start()`
  - Http11ConnectionHandler
    - `process`: ↓ のAprEndpointから返ってきた
      - なんか色々してる
      - `processor.dispatch(nextDispatch.getSocketStatus())`
      - processorはAbstractHttp11ConenctionHandler.createProcessorで作ったもの
  - Http11Processor.dispatch
    - `getAdapter().asyncDispatch(requst, response, status)`: CoyoteAdapter.asyncDispatch

- AprEndpoint
  - ソケットをaccept/pollするスレッド、sendfile用スレッド、ワーカースレッドプールを提供するサービス
  - `startInternal`
    - `*-exec-`ってワーカ用のスレッド作る
      - Connectorに渡された`maxThreads`, `minSpareThreads`, `maxIdleTime`とかここのThreadPoolExecutorに渡す
    - `*-Poller`ってpollする用のスレッド作ってstartさせる
    - sendfileを利用する際には`*-Sendfile`ってスレッド作ってstartさせる
    - `startAcceptorThreads()`: Acceptorってacceptする作って、`*-Acceptor-$i`って名前でスレッド
    - `*-AsyncTimeout`って非同期タイムアウト用のスレッドもstartさせる
  - Acceptor.run
    - 無限ループしてacceptするやつ
    - `connections`ってMapにソケットをkeyにAprSocketWrapperを入れる
    - socketを取得できたら、`processSocketWIthOptions`でexecutorで`SocketWithOptionsProcessor`を渡して実行
  - SocketWithOptionsProcessor.run
    - pollerの`pollers`に、socketをkeyにしたものを追加する
  - Poller.run
    - 無限ループして、`pollers`から取り出したsocketのkeyを用いて、`connections`からArpSocketWrapperを取得
    - 取れたら(色々チェックして)`processSocket`へ
  - `processScoket`
    - `executor.execute(new SocketProcessor(wrapper, status))`
  - SocketProcessor.run
    - `handler.process(socket, status)` (handlerはHttp11AprProtocol.Http11ConnectionHandlerとか)

- CoyoteAdapter
  - `asyncDispatch`
  - ...

続きは次回...

#### references

- [http://telecastravinsky.blog.fc2.com/blog-entry-9.html:title]
- [http://telecastravinsky.blog.fc2.com/blog-entry-10.html:title]
- [http://tomcat.apache.org/tomcat-8.0-doc/architecture/startup/serverStartup.pdf]


### 続き
は次回だったんだけど、以下の２つみたら大体分かったし終わり
- [http://telecastravinsky.blog.fc2.com/blog-entry-11.html]
- [http://tomcat.apache.org/tomcat-8.0-doc/architecture/requestProcess/request-process.png]

Servletを読み込んでるのは、StandarWrapperのallocateあたり
