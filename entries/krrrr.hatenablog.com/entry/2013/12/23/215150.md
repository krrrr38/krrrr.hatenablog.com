---
Title: MeCab, CaboCha で楽々自然言語処理 (Mac + Perl)
Category:
- Perl
Date: 2013-12-23T21:51:50+09:00
URL: https://krrrr.hatenablog.com/entry/2013/12/23/215150
EditURL: https://blog.hatena.ne.jp/krrrr/krrrr.hatenablog.com/atom/entry/12921228815715001963
---

** これ何

Perl で MeCab や CaboCha を使う際の適当にメモ
MeCab に関しては情報が多いが CaboCha はあまり無いので Mac + Perl でしたい方は気持ち参考にして頂けたらと思う

特に自然言語処理の研究がメインではないが、文書構造など適度に取得して使いたい分野
全く触れた事無い人でも便利ライブラリを使う事で以下のように色々遊べる
書く人が書けば以下のような適当なのでもブクマ稼げる

- 例
-- Twitter から tweet を取得し、MeCab で形容詞抽出語に[http://www.cl.ecei.tohoku.ac.jp/index.php?%E5%85%AC%E9%96%8B%E8%B3%87%E6%BA%90%2F%E6%97%A5%E6%9C%AC%E8%AA%9E%E8%A9%95%E4%BE%A1%E6%A5%B5%E6%80%A7%E8%BE%9E%E6%9B%B8:title]を使ってハッシュタグ毎の感性分析を行う
-- 注目ハッシュタグの中からハッピー度合い計算して取り上げるようなサービス
-- MeCab で名詞のみ抽出し、BagOfWords としてベイジアンフィルタにかけてスパム判定，LDA 使ってトピック推定
-- CaboCha で名詞にかかる形容詞を抽出し、名詞毎の極性を算出
-- etc...

文字コードは基本的に utf-8 を使いたい。

** MeCab
文を入力に、単語を分割して名詞が、形容詞が、といった結果を出す形態素解析器

- インストール
-- デフォルトでutf-8の辞書が入る
>|sh|
brew install mecab mecab-ipadic
||<

- Perl で使う際の注意
-- cpanm でのインストール時の文字コードの指定
-- Text::MeCab が返す文字の UTF-8 フラグについて
>|sh|
cpanm --interactive Text::MeCab
||<

>|perl|
#!/usr/bin/env perl
use v5.14;
use strict;
use warnings;
use utf8;

use Text::MeCab;
use Encode qw/decode_utf8 encode_utf8/;

my $text = "すもももももももものうち";
my $mecab = Text::MeCab->new;

my $node = $mecab->parse($text);
while($node) {
    # コード内ではUTF-8フラグの立っている文字列を扱う
    my $surface = decode_utf8 $node->surface; # すもも
    my $feature = decode_utf8 $node->feature; # 名詞,一般,*,*,*,*,すもも,スモモ,スモモ
    # 出力する際はUTF-8フラグを取り除く
    say encode_utf8 $surface;
    say encode_utf8 $feature;
    $node = $node->next;
}

__END__
||<

UTF-8フラグについては、[http://blog.64p.org/entry/20080408/1207619640:title]
>>
入り口で decode して、内部ではすべて flagged utf8 で扱い、出口で encode する。これがすべてです！とにかくこの基本方針をまもっていれば幸せになれます。
<<

プログラム中では `use utf8` で内部文字列はUTF-8フラグを立てたものを使い、入り口で decode 、出口で encode
で、Text::MeCab は Devel::Peek すると分かるが、 UTF-8 フラグの立ってない結果を返すので、外から来たものとして扱い、中で用いる際には decode してから使う。出力するならまた encode する
注意点として、例えば TFIDF とか計算する際に日本語を hash の key にしたいが、UTF-8 フラグの立った文字は key に出来ないので注意

また、通常の辞書だけでなく [http://dumps.wikimedia.org/jawiki/latest/:title=Wikipedia] や [http://d.hatena.ne.jp/hatenadiary/20060922/1158908401:title=はてなキーワード] といったものを扱う事もできる
昔ので Macports とか使ってるけど一応参考記事はこっち [http://krrrr.hatenablog.com/entry/20130311/1363170475:title]
Perl から固有辞書を使う際は `$mecab = Text::MeCab->new({ userdic => 'mydic' })` とか

** CaboCha
文を入力に、「A が B した。」に対して 「A → B」といった結果を出す係り受け解析器

- インストール
-- mecab に依存した CaboCha が入る
>|sh|
brew cabocha
cabocha --version 
||<

CPAN に CaboCha のラッパーライブラリは存在しないが、元々用意されているので[https://code.google.com/p/cabocha/:title]から version の等しい tar.bz2 とか落として解凍
>|sh|
cd cabocha-x.xx/perl
cpanm .
||<

動作確認
>|sh|
perl test.pl
||<

- Perl から CaboCha を使う話
-- 形態素解析の結果を取りたい
形態素解析結果はも取れたりするのだが、上記のようなものが取れたら満足なのではないかと思う
特に Document など無いので必要そうなのだけ考える
中に含まれる CaboCha.pm を見れば良いのだが、依存クラスとして以下のようなものがある
- CaboCha::Parser
-- 文を入力に Parser で parse する事で結果 (Tree) が得られる
- CaboCha::Tree
-- Parser で得られた結果。係り受け構造は test.pl を見て分かるが木のようになる。
- CaboCha::Chunk
-- 係り受け構造の文節単位
-- 例："すももも" - "ももも" - "ももの" - "うち" (chunk size = 4)
- CaboCha::Token
-- 形態素解析結果の最小単位
-- 例 : "「すもも」「も」" - "「もも」「も」" - "「もも」「の」" - "「うち」" (token size = 7)
-- chunk といった文節の中に語がいくつ含まれるといった情報も保持される

>|perl|
#!/usr/bin/env perl
use v5.14;
use strict;
use warnings;
use utf8;

use CaboCha;

my $text = "すもももももももものうち";
my $parser = CaboCha::Parser->new;

my $tree = $parser->parse($text);
my $chunk_number = 0;
for (my $i = 0; $i < $tree->chunk_size; ++$i) {
    my $chunk = $tree->chunk($i);

    # chunk 番号は数え上げる。係り受け先は link で取得
    say sprintf("chunk %d is following chunk %d", $chunk_number++, $chunk->{link});

    # token_size で chunk に含まれる token の数が取れる
    # token_pos で chunk に含まれる token の先頭の index が取れる
    for(my $j = 0; $j < $chunk->{token_size}; ++$j){
        my $token = $tree->token($chunk->{token_pos} + $j); # token

        # ここで得られる値も UTF-8 は立っていないので注意
        say "\t" . $token->{surface} . " : " . $token->{feature};
    }
}

__END__
||<

Token から Chunk を得る事も可能なので、先に形態素解析結果を見た後に名詞がどの文節にかかるか確認したいなどといった場合には、以下のようにしても良い
UTF-8 の立った文字列は decode した上で処理を行うのを忘れないよう
>|perl|
for (my $i = 0; $i < $tree->token_size; ++$i) {
    my $token = $tree->token($i);
    my $feature = decode_utf8($token->{feature});
    if ($feature =~ /^名詞/) {
        my $chunk = $token->{chunk};
        say $token->{surface} . " is following chunk " . $chunk->{link};
    }
}
||<
`$chunk->{link}` が -1 になると、文が終わりとなる
"。" などで区切られた文に対しても CaboCha は係り受け構造があると認めるので、一応気にしておくべきな気がする

一応ではあるが Cabocha.pm に対して、 Token の `*swig_surface_get` といった記述に対して `$token->{surface}` や `$token->swig_surface_get()` がそのまま扱える
